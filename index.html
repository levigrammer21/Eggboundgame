<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EggBound ‚Äî Family Hatch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0b1220" />
  <style>
    :root{
      --bg:#0b1220; --panel:#020617; --text:#e5e7eb; --muted:#94a3b8;
      --line:rgba(255,255,255,.1); --blue:#2563eb; --warn:#ca8a04; --bad:#dc2626; --good:#16a34a;
      --chip:rgba(255,255,255,.06);
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:16px;background:linear-gradient(135deg,#1e293b,#020617);border-bottom:1px solid var(--line)}
    h1{margin:0;font-size:20px}
    .sub{font-size:12px;color:var(--muted)}
    .wrap{padding:14px;max-width:1100px;margin:auto}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tab{padding:8px 12px;border-radius:999px;border:1px solid var(--line);cursor:pointer;font-size:12px;background:var(--panel);user-select:none}
    .tab.active{background:var(--blue)}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:16px;padding:14px;margin-bottom:14px}
    .grid{display:grid;grid-template-columns:380px 1fr;gap:14px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
    button{background:var(--blue);color:white;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:800}
    button:disabled{opacity:.45;cursor:not-allowed}
    button.warn{background:var(--warn)}
    button.danger{background:var(--bad)}
    button.good{background:var(--good)}
    button.ghost{background:transparent;border:1px solid var(--line)}
    button.small{padding:6px 10px;font-size:12px}
    .muted{color:var(--muted);font-size:12px}
    .list{display:flex;flex-direction:column;gap:10px}
    .card{background:#020617;border:1px solid var(--line);border-radius:14px;padding:10px}
    .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .chip{display:inline-block;padding:3px 8px;border-radius:999px;font-size:11px;border:1px solid rgba(255,255,255,.14);background:var(--chip);color:var(--muted)}
    .chip.shiny{border-color:rgba(16,185,129,.55);color:#a7f3d0}
    .chip.fav{border-color:rgba(251,191,36,.55);color:#fde68a}
    select,input,textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--line);
      background:#0b1220;color:var(--text);outline:none
    }
    textarea{min-height:120px;resize:vertical}
    label{display:block;margin:10px 0 6px;color:var(--muted);font-size:12px}
    dialog{border:none;border-radius:16px;padding:0;background:transparent}
    dialog::backdrop{background:rgba(0,0,0,.65)}
    .modal{background:linear-gradient(135deg,#0b1220,#020617);border:1px solid var(--line);border-radius:16px;padding:14px;min-width:min(900px,calc(100vw - 28px))}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
    .kpi{border:1px solid var(--line);border-radius:14px;padding:10px;background:rgba(255,255,255,.02)}
    .kpi .v{font-weight:900;font-size:18px}
    .kpi .l{font-size:11px;color:var(--muted);margin-top:2px}
    .hr{height:1px;background:var(--line);margin:12px 0}
    .sprite{
      width:44px;height:44px;border-radius:14px;border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      display:flex;align-items:center;justify-content:center;overflow:hidden;
    }
    .sprite img{width:44px;height:44px;image-rendering:pixelated}
  </style>
</head>
<body>
<header>
  <h1>EggBound ‚Äî Family Hatch</h1>
  <div class="sub">3 trainers ‚Ä¢ mystery eggs ‚Ä¢ biome searching ‚Ä¢ breeding ‚Ä¢ trading ‚Ä¢ shinies ‚Ä¢ sprites ‚Ä¢ release for ‚Ç±</div>
</header>

<div class="wrap">
  <div class="tabs" id="trainerTabs"></div>

  <div class="grid">
    <section class="panel">
      <div class="row">
        <div>
          <div class="muted">Local date: <span class="mono" id="today"></span></div>
          <div class="muted">Trainer: <b id="trainerName"></b></div>
          <div class="muted">Save: <b id="saveHealth">Loading‚Ä¶</b></div>
        </div>
        <div class="row" style="justify-content:flex-end;gap:8px">
          <button class="ghost" id="btnSaveTools">Save Tools</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>
      </div>

      <div class="kpis">
        <div class="kpi"><div class="v" id="kPoke">0</div><div class="l">Pok√©mon</div></div>
        <div class="kpi"><div class="v" id="kEgg">0</div><div class="l">Eggs</div></div>
        <div class="kpi"><div class="v" id="kShiny">0</div><div class="l">Shinies</div></div>
        <div class="kpi"><div class="v" id="kMoney">0</div><div class="l">Pok√©Dollars</div></div>
      </div>

      <div class="hr"></div>

      <h3 style="margin:0 0 8px">Eggs</h3>
      <div class="row" style="justify-content:flex-start">
        <button id="btnWildEgg">Claim Wild Egg (6h)</button>
        <button class="warn" id="btnBuyEgg">Buy Egg (5 ‚Ç±)</button>
        <div class="muted">Balance: <b id="money">0</b> ‚Ç±</div>
      </div>
      <div class="muted" id="cooldownText" style="margin-top:6px"></div>
      <div class="muted" id="buyText" style="margin-top:6px"></div>

      <div class="hr"></div>

      <h3 style="margin:0 0 8px">Biome Search</h3>
      <div class="muted">Each trainer can search for <b>one</b> biome egg at a time. Search takes <b>5‚Äì30 minutes</b>. Egg stays a mystery until hatch.</div>
      <label>Biome</label>
      <select id="biomeSelect"></select>
      <div class="row" style="justify-content:flex-start;margin-top:10px">
        <button class="good" id="btnStartSearch">Start Search</button>
        <button class="warn" id="btnClaimSearchEgg" disabled>Claim Found Egg</button>
        <div class="muted" id="searchText"></div>
      </div>

      <div class="hr"></div>

      <h3 style="margin:0 0 8px">Breeding (1/day)</h3>
      <div class="muted">Pick 2 Pok√©mon of different genders that share at least one type. Egg arrives <b>tomorrow</b>, hatches <b>1 hour</b> after arrival. Species stays hidden until hatch.</div>
      <label>Parent A</label>
      <select id="parentA"></select>
      <label>Parent B</label>
      <select id="parentB"></select>
      <div class="row" style="justify-content:flex-start;margin-top:10px">
        <button class="good" id="btnBreed">Start Breed</button>
        <div class="muted" id="breedText"></div>
      </div>

      <div class="hr"></div>

      <h3 style="margin:0 0 8px">Trading</h3>
      <div class="muted">Trade eggs or Pok√©mon between your 3 trainers instantly.</div>
      <div class="row" style="justify-content:flex-start;margin-top:10px">
        <button class="warn" id="btnTrade">Open Trade Center</button>
        <button class="ghost" id="btnEditNames">Edit Names</button>
      </div>
    </section>

    <section class="panel">
      <div class="tabs">
        <div class="tab active" data-view="eggs">Egg Vault</div>
        <div class="tab" data-view="pokemon">Pok√©mon</div>
        <div class="tab" data-view="dex">Dex</div>
      </div>

      <div class="row" style="justify-content:flex-start;margin-top:10px">
        <input id="search" placeholder="Search (name / type / shiny)" style="flex:1;min-width:220px" />
        <select id="sort" style="width:220px">
          <option value="newest">Sort: Newest</option>
          <option value="oldest">Sort: Oldest</option>
          <option value="name">Sort: Name</option>
          <option value="shiny">Sort: Shiny first</option>
        </select>
      </div>

      <div class="hr"></div>

      <div id="view-eggs" class="list"></div>
      <div id="view-pokemon" class="list" style="display:none"></div>
      <div id="view-dex" style="display:none">
        <div class="muted">Dex tracks owned species + shiny seen. Sprites show after you hatch that species.</div>
        <div class="hr"></div>
        <div class="list" id="dexList"></div>
      </div>
    </section>
  </div>
</div>

<!-- Names Modal -->
<dialog id="dlgNames">
  <div class="modal">
    <div class="row">
      <h3 style="margin:0">Edit Trainer Names</h3>
      <button class="ghost" id="btnCloseNames">Close</button>
    </div>
    <label>Trainer 1</label><input id="n1">
    <label>Trainer 2</label><input id="n2">
    <label>Trainer 3</label><input id="n3">
    <div class="row" style="justify-content:flex-start;margin-top:12px">
      <button id="btnSaveNames">Save</button>
      <div class="muted">Stored only on this device.</div>
    </div>
  </div>
</dialog>

<!-- Trade Modal -->
<dialog id="dlgTrade">
  <div class="modal">
    <div class="row">
      <h3 style="margin:0">Trade Center</h3>
      <button class="ghost" id="btnCloseTrade">Close</button>
    </div>
    <div class="muted">From: <b id="tradeFrom"></b></div>

    <label>Trade Type</label>
    <select id="tradeType">
      <option value="pokemon">Pok√©mon</option>
      <option value="egg">Egg</option>
    </select>

    <label>Item</label>
    <select id="tradeItem"></select>

    <label>To Trainer</label>
    <select id="tradeTo"></select>

    <div class="row" style="justify-content:flex-start;margin-top:12px">
      <button class="warn" id="btnDoTrade">Confirm Trade</button>
      <div class="muted" id="tradeText"></div>
    </div>
  </div>
</dialog>

<!-- Save Tools Modal -->
<dialog id="dlgSave">
  <div class="modal">
    <div class="row">
      <h3 style="margin:0">Save Tools (Local + Backups)</h3>
      <button class="ghost" id="btnCloseSave">Close</button>
    </div>

    <div class="muted">This prevents losing progress from normal web hiccups. For true safety, download a backup occasionally.</div>
    <div class="hr"></div>

    <div class="row" style="justify-content:flex-start">
      <button class="good" id="btnBackupNow">Backup Now</button>
      <button class="ghost" id="btnDownloadBackup">Download Latest Backup</button>
      <label class="ghost" style="padding:10px 14px;border-radius:12px;border:1px solid var(--line);cursor:pointer">
        Restore Backup File <input id="fileRestore" type="file" accept="application/json" style="display:none">
      </label>
    </div>

    <div class="hr"></div>

    <h3 style="margin:0 0 8px">Save Code (copy/paste)</h3>
    <div class="muted">Copy this into Notes. You can restore from it any time.</div>
    <label>Code</label>
    <textarea id="saveCode" class="mono" placeholder="Generate a code first‚Ä¶"></textarea>
    <div class="row" style="justify-content:flex-start">
      <button id="btnGenCode">Generate Code</button>
      <button class="ghost" id="btnCopyCode">Copy</button>
      <button class="warn" id="btnRestoreCode">Restore From Code</button>
    </div>

    <div class="hr"></div>

    <div class="muted">Backups kept on device: <b id="backupCount">0</b> (keeps last 10)</div>
    <div class="muted" id="saveMsg"></div>
  </div>
</dialog>

<script>
(() => {
  "use strict";

  /* =========================
     Better Save System (A)
     - IndexedDB primary
     - Mirror copy
     - Daily backups (last 10)
     - Manual backup/export/restore
     - Save code (copy/paste)
     ========================= */

  const DB_NAME = "eggbound_db";
  const DB_VER = 1;
  const STORE_MAIN = "kv";
  const STORE_BACKUPS = "backups";
  const KEY_MAIN = "state_main";
  const KEY_MIRROR = "state_mirror";
  const KEY_META = "meta";
  const MAX_BACKUPS = 10;

  const $ = (id)=>document.getElementById(id);
  const now = ()=>Date.now();
  const uid = ()=>Math.random().toString(16).slice(2)+"-"+Math.random().toString(16).slice(2);
  const cap = (s)=>s ? (s[0].toUpperCase()+s.slice(1)) : "";
  const dayKey = (ts=Date.now()) => {
    const d=new Date(ts);
    const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,"0"), dd=String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${dd}`;
  };
  const tomorrowMidnight = (ts=Date.now()) => { const d=new Date(ts); d.setHours(24,0,0,0); return d.getTime(); };
  const fmtLeft = (ms)=>{
    if(!Number.isFinite(ms) || ms<=0) return "Ready!";
    const s=Math.floor(ms/1000), h=Math.floor(s/3600), m=Math.floor((s%3600)/60), ss=s%60;
    if(h>0) return `${h}h ${m}m`;
    if(m>0) return `${m}m ${ss}s`;
    return `${ss}s`;
  };

  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains(STORE_MAIN)) db.createObjectStore(STORE_MAIN);
        if(!db.objectStoreNames.contains(STORE_BACKUPS)){
          const bs = db.createObjectStore(STORE_BACKUPS, {keyPath:"id"});
          bs.createIndex("ts", "ts");
        }
      };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }

  async function idbGet(store, key){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store, "readonly");
      const st = tx.objectStore(store);
      const req = st.get(key);
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
      tx.oncomplete = ()=>db.close();
    });
  }

  async function idbSet(store, key, value){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store, "readwrite");
      const st = tx.objectStore(store);
      const req = st.put(value, key);
      req.onsuccess = ()=>resolve(true);
      req.onerror = ()=>reject(req.error);
      tx.oncomplete = ()=>db.close();
    });
  }

  async function idbAddBackup(obj){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(STORE_BACKUPS, "readwrite");
      const st = tx.objectStore(STORE_BACKUPS);
      const req = st.add(obj);
      req.onsuccess = ()=>resolve(true);
      req.onerror = ()=>reject(req.error);
      tx.oncomplete = ()=>db.close();
    });
  }

  async function idbListBackups(){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(STORE_BACKUPS, "readonly");
      const st = tx.objectStore(STORE_BACKUPS);
      const idx = st.index("ts");
      const req = idx.getAll();
      req.onsuccess = ()=>resolve(req.result || []);
      req.onerror = ()=>reject(req.error);
      tx.oncomplete = ()=>db.close();
    });
  }

  async function idbDeleteBackup(id){
    const db = await openDB();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(STORE_BACKUPS, "readwrite");
      const st = tx.objectStore(STORE_BACKUPS);
      const req = st.delete(id);
      req.onsuccess = ()=>resolve(true);
      req.onerror = ()=>reject(req.error);
      tx.oncomplete = ()=>db.close();
    });
  }

  function stableClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  // Compression-free ‚Äúsave code‚Äù (simple base64). Works offline.
  function toSaveCode(obj){
    const json = JSON.stringify(obj);
    const bytes = new TextEncoder().encode(json);
    let bin = "";
    for(const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }
  function fromSaveCode(code){
    const bin = atob(code.trim());
    const bytes = new Uint8Array([...bin].map(ch=>ch.charCodeAt(0)));
    const json = new TextDecoder().decode(bytes);
    return JSON.parse(json);
  }

  async function saveState(state){
    const payload = stableClone(state);
    const ts = now();
    payload._saveMeta = { ts, v: 1 };

    // write main then mirror
    await idbSet(STORE_MAIN, KEY_MAIN, payload);
    await idbSet(STORE_MAIN, KEY_MIRROR, payload);

    // update meta
    const meta = (await idbGet(STORE_MAIN, KEY_META)) || {};
    meta.lastSaveTs = ts;
    await idbSet(STORE_MAIN, KEY_META, meta);

    // optional: legacy mirror (just in case)
    try { localStorage.setItem("eggbound_legacy_mirror", JSON.stringify(payload)); } catch {}
    setSaveHealth("OK");
  }

  async function loadState(){
    // prefer IDB main -> mirror -> legacy mirror -> default
    const main = await safeGetMain(KEY_MAIN);
    if(main) return main;

    const mirror = await safeGetMain(KEY_MIRROR);
    if(mirror) return mirror;

    try{
      const legacy = localStorage.getItem("eggbound_legacy_mirror");
      if(legacy) return JSON.parse(legacy);
    }catch{}

    return defaultState();
  }

  async function safeGetMain(key){
    try{
      const v = await idbGet(STORE_MAIN, key);
      if(!v) return null;
      if(!v.trainers || !Array.isArray(v.trainers) || v.trainers.length!==3) return null;
      return v;
    }catch{
      return null;
    }
  }

  async function ensureDailyBackup(state){
    const meta = (await idbGet(STORE_MAIN, KEY_META)) || {};
    const today = dayKey();
    if(meta.lastBackupDay === today) return;

    await makeBackup(state, `Daily ${today}`);
    meta.lastBackupDay = today;
    await idbSet(STORE_MAIN, KEY_META, meta);
  }

  async function makeBackup(state, label){
    const snap = stableClone(state);
    const b = { id: uid(), ts: now(), label, state: snap };
    await idbAddBackup(b);

    // enforce MAX_BACKUPS
    const all = await idbListBackups();
    all.sort((a,b)=>a.ts-b.ts);
    while(all.length > MAX_BACKUPS){
      const oldest = all.shift();
      await idbDeleteBackup(oldest.id);
    }
  }

  async function getLatestBackup(){
    const all = await idbListBackups();
    if(!all.length) return null;
    all.sort((a,b)=>b.ts-a.ts);
    return all[0];
  }

  /* =========================
     Game Rules / State
     ========================= */

  const POKEAPI_LIST = "https://pokeapi.co/api/v2/pokemon?limit=2000&offset=0";
  const POKEAPI = "https://pokeapi.co/api/v2/pokemon/";
  const WILD_COOLDOWN = 6*60*60*1000;
  const HATCH_MS = 1*60*60*1000;
  const SHINY_WILD = 1/256;
  const SHINY_BREED = 1/192;
  const OUTLIER_CHANCE = 0.05;
  const NORMAL_RANGE = 0.10;
  const OUTLIER_RANGE = 0.20;
  const BUY_COST = 5;
  const RELEASE_REWARD = 1;

  const BIOMES = [
    { id:"forest",   name:"Forest",   types:["grass","bug","normal"] },
    { id:"mountain", name:"Mountain", types:["rock","ground","ice"] },
    { id:"ocean",    name:"Ocean",    types:["water","ice"] },
    { id:"cave",     name:"Cave",     types:["rock","ghost","poison"] },
    { id:"desert",   name:"Desert",   types:["ground","fire"] },
    { id:"swamp",    name:"Swamp",    types:["poison","water","grass"] },
    { id:"sky",      name:"Sky",      types:["flying","electric"] },
    { id:"city",     name:"City",     types:["normal","steel","electric"] },
    { id:"volcano",  name:"Volcano",  types:["fire","rock"] },
    { id:"tundra",   name:"Tundra",   types:["ice"] }
  ];

  function defaultState(){
    return {
      money:0,
      active:0,
      trainers:[
        {name:"Trainer 1", eggs:[], pokemon:[], flags:{lastWildEggAt:0, lastBreed:null}, search:null},
        {name:"Trainer 2", eggs:[], pokemon:[], flags:{lastWildEggAt:0, lastBreed:null}, search:null},
        {name:"Trainer 3", eggs:[], pokemon:[], flags:{lastWildEggAt:0, lastBreed:null}, search:null},
      ],
      pokeCache:{}, // name -> {types, heightIn, weightLb, sprite}
      dex:{}        // name -> {firstSeen, ownedCount, shinySeen, sprite}
    };
  }

  let state = null;
  let saveQueued = false;

  function t(){ return state.trainers[state.active]; }

  function queueSave(){
    if(saveQueued) return;
    saveQueued = true;
    setTimeout(async ()=>{
      saveQueued = false;
      await saveState(state);
      await ensureDailyBackup(state);
      refreshBackupCount();
    }, 150);
  }

  function setSaveHealth(txt){
    if($("saveHealth")) $("saveHealth").textContent = txt;
  }

  async function fetchJSON(url){
    const r = await fetch(url);
    if(!r.ok) throw new Error("network");
    return await r.json();
  }

  async function getAllNames(){
    if(getAllNames._list) return getAllNames._list;
    try{
      const d = await fetchJSON(POKEAPI_LIST);
      getAllNames._list = d.results.map(x=>x.name);
    }catch{
      getAllNames._list = ["pikachu","bulbasaur","charmander","squirtle","eevee","pidgey","geodude","gastly","magikarp","dratini"];
    }
    return getAllNames._list;
  }

  function toInches(dm){ return dm * 3.937007874; }
  function toPounds(hg){ return hg * 0.220462262; }

  async function ensureInfo(name){
    name = String(name||"").toLowerCase();
    if(state.pokeCache[name]) return state.pokeCache[name];
    const d = await fetchJSON(POKEAPI+name);
    const info = {
      types: (d.types||[]).map(x=>x.type.name),
      heightIn: d.height!=null ? toInches(d.height) : 24,
      weightLb: d.weight!=null ? toPounds(d.weight) : 10,
      sprite: d.sprites?.front_default || null
    };
    state.pokeCache[name] = info;
    queueSave();
    return info;
  }

  const rollGender = ()=>Math.random()<0.5 ? "M" : "F";
  const rollShiny = (src)=>Math.random() < (src==="breed" ? SHINY_BREED : SHINY_WILD);

  function rollSize(base, isOutlier){
    const range = isOutlier ? OUTLIER_RANGE : NORMAL_RANGE;
    const lo = 1-range, hi = 1+range;
    const mult = lo + Math.random()*(hi-lo);
    return Math.round(Math.max(0.1, base*mult)*10)/10;
  }
  function rollHeightWeight(baseIn, baseLb){
    const outlier = Math.random() < OUTLIER_CHANCE;
    return { height: rollSize(baseIn, outlier), weight: rollSize(baseLb, outlier), outlier };
  }

  async function addEgg({source, species=null, hintTypes=null, poolTypes=null, arrivesAt=null, parents=null, biome=null}){
    const shiny = rollShiny(source==="breed" ? "breed" : "wild");
    const egg = {
      id: uid(),
      createdAt: now(),
      source,
      arrivesAt,
      readyAt: (arrivesAt ? arrivesAt + HATCH_MS : now() + HATCH_MS),
      species,
      hintTypes,
      poolTypes,
      parents,
      biome,
      shiny
    };
    t().eggs.unshift(egg);
    queueSave();
    return egg;
  }

  async function pickAnySpecies(){
    const names = await getAllNames();
    return names[Math.floor(Math.random()*names.length)];
  }

  async function pickSpeciesByTypes(types){
    const names = await getAllNames();
    if(!types || !types.length) return pickAnySpecies();

    for(let i=0;i<240;i++){
      const pick = names[Math.floor(Math.random()*names.length)];
      const cached = state.pokeCache[pick];
      if(cached && cached.types && cached.types.some(x => types.includes(x))) return pick;
    }

    for(let i=0;i<18;i++){
      const pick = names[Math.floor(Math.random()*names.length)];
      try{
        const info = await ensureInfo(pick);
        if(info.types && info.types.some(x => types.includes(x))) return pick;
      }catch{}
    }

    return pickAnySpecies();
  }

  async function claimWildEgg(){
    const last = t().flags.lastWildEggAt || 0;
    const elapsed = now() - last;
    if(elapsed < WILD_COOLDOWN) return;

    await addEgg({source:"wild", species:null, hintTypes:["???"], poolTypes:null});
    t().flags.lastWildEggAt = now();
    queueSave();
    renderAll();
  }

  async function buyEgg(){
    state.money = state.money || 0;
    if(state.money < BUY_COST) return;
    state.money -= BUY_COST;
    queueSave();
    await addEgg({source:"purchase", species:null, hintTypes:["???"], poolTypes:null});
    renderAll();
  }

  function populateBiomes(){
    $("biomeSelect").innerHTML = BIOMES.map(b=>`<option value="${b.id}">${b.name} (${b.types.join("/")})</option>`).join("");
  }

  function startBiomeSearch(){
    if(t().search && now() < t().search.endsAt) return;
    const biomeId = $("biomeSelect").value;
    const biome = BIOMES.find(b=>b.id===biomeId) || BIOMES[0];
    const minutes = 5 + Math.floor(Math.random()*26);
    const endsAt = now() + minutes*60*1000;
    t().search = { biomeId: biome.id, endsAt, claimed:false };
    queueSave();
    renderAll();
  }

  async function claimBiomeEgg(){
    const s = t().search;
    if(!s) return;
    if(now() < s.endsAt) return;

    const biome = BIOMES.find(b=>b.id===s.biomeId);
    const types = biome ? biome.types : ["???"];

    await addEgg({
      source:"biome",
      species:null,
      hintTypes:[`Biome: ${biome ? biome.name : "Unknown"}`].concat(types),
      poolTypes: types,
      biome: biome ? biome.id : null
    });

    t().search = null;
    queueSave();
    renderAll();
  }

  async function startBreed(){
    const today = dayKey();
    if(t().flags.lastBreed === today) return;

    const aId = $("parentA").value;
    const bId = $("parentB").value;
    if(!aId || !bId || aId===bId) return;

    const a = t().pokemon.find(x=>x.id===aId);
    const b = t().pokemon.find(x=>x.id===bId);
    if(!a || !b) return;
    if(a.gender === b.gender) return;

    const shared = (a.types||[]).filter(x => (b.types||[]).includes(x));
    if(shared.length === 0) return;

    const sharedType = shared[Math.floor(Math.random()*shared.length)];
    const arrive = tomorrowMidnight();

    await addEgg({
      source:"breed",
      species:null,
      hintTypes:[`Breed: ${sharedType}`],
      poolTypes:[sharedType],
      arrivesAt: arrive,
      parents:{a:a.name,b:b.name,type:sharedType}
    });

    t().flags.lastBreed = today;
    queueSave();
    renderAll();
  }

  async function hatchEgg(eggId){
    const egg = t().eggs.find(e=>e.id===eggId);
    if(!egg) return;

    if(egg.arrivesAt && now() < egg.arrivesAt) return;
    if(now() < egg.readyAt) return;

    if(!egg.species){
      if(egg.source==="breed" || egg.source==="biome"){
        const types = egg.poolTypes || (egg.parents?.type ? [egg.parents.type] : null);
        egg.species = await pickSpeciesByTypes(types);
      } else {
        egg.species = await pickAnySpecies();
      }
    }

    let info;
    try{ info = await ensureInfo(egg.species); }
    catch{ info = {types:[], heightIn:24, weightLb:10, sprite:null}; }

    const sz = rollHeightWeight(info.heightIn, info.weightLb);

    const mon = {
      id: uid(),
      name: egg.species,
      types: info.types || [],
      gender: rollGender(),
      shiny: !!egg.shiny,
      height: sz.height,
      weight: sz.weight,
      outlier: sz.outlier,
      favorite: false,
      hatchedAt: now(),
      sprite: info.sprite || null
    };

    const key = mon.name;
    if(!state.dex[key]) state.dex[key] = {firstSeen: now(), ownedCount: 0, shinySeen:false, sprite: mon.sprite || null};
    state.dex[key].ownedCount += 1;
    if(mon.shiny) state.dex[key].shinySeen = true;
    if(!state.dex[key].sprite && mon.sprite) state.dex[key].sprite = mon.sprite;

    t().eggs = t().eggs.filter(e=>e.id!==eggId);
    t().pokemon.unshift(mon);
    queueSave();
    renderAll();
  }

  function toggleFavorite(monId){
    const m = t().pokemon.find(x=>x.id===monId);
    if(!m) return;
    m.favorite = !m.favorite;
    queueSave();
    renderAll();
  }

  function releasePokemon(monId){
    const m = t().pokemon.find(x=>x.id===monId);
    if(!m) return;
    const ok = confirm(`Release ${cap(m.name)}${m.shiny?" ‚ú®":""}${m.favorite?" ‚≠ê":""}? This is forever.`);
    if(!ok) return;
    t().pokemon = t().pokemon.filter(x=>x.id!==monId);
    state.money = (state.money||0) + RELEASE_REWARD;
    queueSave();
    renderAll();
  }

  function openTrade(){
    $("dlgTrade").showModal();
    $("tradeFrom").textContent = t().name;
    rebuildTrade();
  }

  function rebuildTrade(){
    const fromIdx = state.active;
    const type = $("tradeType").value;

    $("tradeTo").innerHTML = "";
    state.trainers.forEach((tr, idx)=>{
      if(idx===fromIdx) return;
      const opt = document.createElement("option");
      opt.value = String(idx);
      opt.textContent = tr.name;
      $("tradeTo").appendChild(opt);
    });

    const items = (type==="egg") ? t().eggs : t().pokemon;
    $("tradeItem").innerHTML = "";
    items.forEach(it=>{
      const opt = document.createElement("option");
      opt.value = it.id;
      if(type==="egg"){
        const hint = (it.hintTypes && it.hintTypes.length) ? it.hintTypes.join("/") : "???";
        opt.textContent = `${it.shiny?"‚ú® ":""}Egg ‚Ä¢ ${hint} ‚Ä¢ ${it.source}`;
      }else{
        opt.textContent = `${it.favorite?"‚≠ê ":""}${it.shiny?"‚ú® ":""}${cap(it.name)} ‚Ä¢ ${it.gender} ‚Ä¢ ${(it.types||[]).join("/")}`;
      }
      $("tradeItem").appendChild(opt);
    });

    $("tradeText").textContent = items.length ? "" : "Nothing to trade yet.";
  }

  function doTrade(){
    const type = $("tradeType").value;
    const itemId = $("tradeItem").value;
    const toIdx = Number($("tradeTo").value);
    if(!Number.isFinite(toIdx)) return;

    const from = state.trainers[state.active];
    const to = state.trainers[toIdx];
    if(!from || !to) return;

    let item = null;
    if(type==="egg") item = from.eggs.find(e=>e.id===itemId);
    else item = from.pokemon.find(p=>p.id===itemId);
    if(!item) return;

    const risky = (type==="egg" && item.shiny) || (type==="pokemon" && (item.shiny || item.favorite));
    if(risky){
      const ok = confirm("This trade includes a shiny and/or favorite. Continue?");
      if(!ok) return;
    }

    if(type==="egg"){
      from.eggs = from.eggs.filter(e=>e.id!==itemId);
      to.eggs.unshift(item);
    }else{
      from.pokemon = from.pokemon.filter(p=>p.id!==itemId);
      to.pokemon.unshift(item);
    }

    queueSave();
    rebuildTrade();
    renderAll();
  }

  /* =========================
     Render
     ========================= */

  function matchesSearch(obj, q){
    if(!q) return true;
    q = q.toLowerCase().trim();
    const hay = [
      obj.name||"",
      ...(obj.types||[]),
      obj.shiny ? "shiny" : "",
      obj.gender||"",
      obj.source||""
    ].join(" ").toLowerCase();
    return hay.includes(q);
  }

  function sortItems(arr, mode){
    const a = [...arr];
    if(mode==="newest") a.sort((x,y)=>(y.hatchedAt||y.createdAt||0)-(x.hatchedAt||x.createdAt||0));
    if(mode==="oldest") a.sort((x,y)=>(x.hatchedAt||x.createdAt||0)-(y.hatchedAt||y.createdAt||0));
    if(mode==="name") a.sort((x,y)=>(x.name||"").localeCompare(y.name||""));
    if(mode==="shiny") a.sort((x,y)=>(y.shiny?1:0)-(x.shiny?1:0));
    return a;
  }

  function renderTabs(){
    const el = $("trainerTabs");
    el.innerHTML = "";
    state.trainers.forEach((tr,i)=>{
      const b = document.createElement("div");
      b.className = "tab"+(i===state.active?" active":"");
      b.textContent = tr.name;
      b.onclick = ()=>{ state.active=i; queueSave(); renderAll(); };
      el.appendChild(b);
    });
  }

  function renderKPIs(){
    $("trainerName").textContent = t().name;
    $("today").textContent = dayKey();
    $("kPoke").textContent = String(t().pokemon.length);
    $("kEgg").textContent = String(t().eggs.length);
    $("kShiny").textContent = String(t().pokemon.filter(p=>p.shiny).length);
    $("kMoney").textContent = String(state.money||0);
    $("money").textContent = String(state.money||0);
  }

  function renderEggButtons(){
    const last = t().flags.lastWildEggAt || 0;
    const left = WILD_COOLDOWN - (now()-last);
    const onCd = left > 0;
    $("btnWildEgg").disabled = onCd;
    $("cooldownText").textContent = onCd ? `‚è≥ Next wild egg in ${fmtLeft(left)}.` : "You can claim a wild mystery egg every 6 hours.";

    const need = Math.max(0, BUY_COST - (state.money||0));
    $("btnBuyEgg").disabled = (state.money||0) < BUY_COST;
    $("buyText").textContent = need>0 ? `Need ${need} more ‚Ç± to buy an egg (release Pok√©mon to earn).` : "";

    const s = t().search;
    if(!s){
      $("searchText").textContent = "Not searching.";
      $("btnClaimSearchEgg").disabled = true;
      $("btnStartSearch").disabled = false;
    }else{
      const leftS = s.endsAt - now();
      if(leftS > 0){
        $("searchText").textContent = `Searching‚Ä¶ ${fmtLeft(leftS)} left.`;
        $("btnClaimSearchEgg").disabled = true;
        $("btnStartSearch").disabled = true;
      }else{
        $("searchText").textContent = "‚úÖ Egg found! Claim it.";
        $("btnClaimSearchEgg").disabled = false;
        $("btnStartSearch").disabled = true;
      }
    }
  }

  function renderBreed(){
    const today = dayKey();
    const used = (t().flags.lastBreed === today);
    $("btnBreed").disabled = used || t().pokemon.length < 2;
    $("breedText").textContent = used ? "‚úÖ Breeding already used today." : "";

    const opts = t().pokemon.map(m => {
      return `<option value="${m.id}">${cap(m.name)}${m.shiny?" ‚ú®":""} ‚Ä¢ ${m.gender} ‚Ä¢ ${(m.types||[]).join("/")}</option>`;
    }).join("");
    $("parentA").innerHTML = `<option value="">Select‚Ä¶</option>` + opts;
    $("parentB").innerHTML = `<option value="">Select‚Ä¶</option>` + opts;

    outer: for(const a of t().pokemon){
      for(const b of t().pokemon){
        if(a.id===b.id) continue;
        if(a.gender===b.gender) continue;
        const shared = (a.types||[]).filter(x=>(b.types||[]).includes(x));
        if(shared.length){ $("parentA").value=a.id; $("parentB").value=b.id; break outer; }
      }
    }
  }

  function eggCard(e){
    const arrived = !e.arrivesAt || now() >= e.arrivesAt;
    const left = arrived ? (e.readyAt - now()) : (e.arrivesAt - now());
    const status = arrived ? (now() >= e.readyAt ? "Ready!" : "Incubating") : "Arriving";
    const src = e.source==="breed" ? `Breed` : (e.source==="purchase" ? "Purchased" : (e.source==="biome" ? "Biome" : "Wild"));
    const hint = (e.hintTypes && e.hintTypes.length) ? e.hintTypes.join(" / ") : "???";
    const canHatch = arrived && now() >= e.readyAt;

    return `
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div>
            <b>ü•ö Mystery Egg</b> <span class="muted">‚Ä¢ ${status}</span>
            <div class="chips">
              <span class="chip">${src}</span>
              <span class="chip">${hint}</span>
              ${e.shiny ? `<span class="chip shiny">‚ú® Shiny</span>` : ``}
              <span class="chip">‚è≥ ${fmtLeft(left)}</span>
            </div>
          </div>
          <button class="small good" data-hatch="${e.id}" ${canHatch?"":"disabled"}>Hatch</button>
        </div>
      </div>
    `;
  }

  function monCard(m){
    const sprite = m.sprite ? `<img src="${m.sprite}" alt="">` : "‚¨õ";
    return `
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div class="row" style="justify-content:flex-start;gap:10px">
            <div class="sprite">${sprite}</div>
            <div>
              <b>${cap(m.name)} ${m.shiny?"‚ú®":""}</b>
              <div class="chips">
                ${m.shiny ? `<span class="chip shiny">‚ú® Shiny</span>` : ``}
                ${m.favorite ? `<span class="chip fav">‚≠ê Favorite</span>` : ``}
                <span class="chip">${m.gender}</span>
                <span class="chip">${m.outlier ? "üìè" : "üìê"} H: ${m.height} in</span>
                <span class="chip">${m.outlier ? "‚ö†Ô∏è" : "‚öñÔ∏è"} W: ${m.weight} lb</span>
                ${(m.types||[]).map(t=>`<span class="chip">${t}</span>`).join("")}
              </div>
              <div class="muted">Hatched: ${new Date(m.hatchedAt).toLocaleString()}</div>
            </div>
          </div>
          <div class="row" style="justify-content:flex-end">
            <button class="small ghost" data-fav="${m.id}">${m.favorite?"Unfavorite":"Favorite"}</button>
            <button class="small danger" data-release="${m.id}">Release (+‚Ç±)</button>
          </div>
        </div>
      </div>
    `;
  }

  function dexCard(name, d){
    const sprite = d.sprite ? `<img src="${d.sprite}" alt="">` : "üìò";
    return `
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div class="row" style="justify-content:flex-start;gap:10px">
            <div class="sprite">${sprite}</div>
            <div>
              <b>${cap(name)}</b>
              <div class="chips">
                <span class="chip">Owned: ${d.ownedCount||0}</span>
                <span class="chip">${d.shinySeen ? "‚ú® Shiny seen" : "No shiny yet"}</span>
                <span class="chip">First: ${new Date(d.firstSeen).toLocaleDateString()}</span>
              </div>
            </div>
          </div>
          <div class="muted">${d.shinySeen ? "‚ú®" : ""}</div>
        </div>
      </div>
    `;
  }

  function renderView(){
    const q = $("search").value || "";
    const sort = $("sort").value;

    const eggs = sortItems(t().eggs.filter(e=>matchesSearch({name:"egg", types:e.hintTypes||[], shiny:e.shiny, source:e.source}, q)), sort);
    $("view-eggs").innerHTML = eggs.map(eggCard).join("") || `<div class="muted">No eggs yet. Claim/search/buy one!</div>`;

    const mons = sortItems(t().pokemon.filter(m=>matchesSearch(m, q)), sort);
    $("view-pokemon").innerHTML = mons.map(monCard).join("") || `<div class="muted">No Pok√©mon yet. Hatch an egg!</div>`;

    const entries = Object.entries(state.dex || {});
    entries.sort((a,b)=>(b[1].ownedCount||0)-(a[1].ownedCount||0) || a[0].localeCompare(b[0]));
    const dq = q.toLowerCase().trim();
    const filtered = entries.filter(([nm,d])=>{
      if(!dq) return true;
      if(nm.includes(dq)) return true;
      if(d.shinySeen && dq.includes("shiny")) return true;
      return false;
    });
    $("dexList").innerHTML = filtered.map(([n,d])=>dexCard(n,d)).join("") || `<div class="muted">Dex is empty. Hatch something!</div>`;
  }

  function switchView(view){
    document.querySelectorAll('[data-view]').forEach(el=>{
      el.classList.toggle("active", el.getAttribute("data-view")===view);
    });
    $("view-eggs").style.display = view==="eggs" ? "" : "none";
    $("view-pokemon").style.display = view==="pokemon" ? "" : "none";
    $("view-dex").style.display = view==="dex" ? "" : "none";
    renderView();
  }

  function renderAll(){
    renderTabs();
    renderKPIs();
    renderEggButtons();
    renderBreed();
    renderView();
    if($("dlgTrade").open) rebuildTrade();
  }

  /* =========================
     Save Tools UI
     ========================= */

  async function refreshBackupCount(){
    try{
      const all = await idbListBackups();
      $("backupCount").textContent = String(all.length);
    }catch{
      $("backupCount").textContent = "0";
    }
  }

  async function backupNow(){
    await makeBackup(state, `Manual ${new Date().toLocaleString()}`);
    $("saveMsg").textContent = "‚úÖ Backup created.";
    refreshBackupCount();
  }

  async function downloadLatestBackup(){
    const latest = await getLatestBackup();
    if(!latest){
      $("saveMsg").textContent = "No backups yet.";
      return;
    }
    const blob = new Blob([JSON.stringify(latest.state,null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href=url;
    a.download=`eggbound_backup_${dayKey(latest.ts)}.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    $("saveMsg").textContent = "‚¨áÔ∏è Downloaded latest backup.";
  }

  async function restoreFromFile(file){
    const reader = new FileReader();
    reader.onload = async () => {
      try{
        const obj = JSON.parse(reader.result);
        if(!obj || !obj.trainers || obj.trainers.length!==3) throw new Error("bad");
        state = obj;
        await saveState(state);
        await makeBackup(state, `Restore ${new Date().toLocaleString()}`);
        $("saveMsg").textContent = "‚úÖ Restored from backup file.";
        renderAll();
        refreshBackupCount();
      }catch{
        $("saveMsg").textContent = "‚ùå That file didn‚Äôt look like an EggBound save.";
      }
    };
    reader.readAsText(file);
  }

  function genCode(){
    try{
      $("saveCode").value = toSaveCode(state);
      $("saveMsg").textContent = "‚úÖ Code generated. Copy it somewhere safe.";
    }catch{
      $("saveMsg").textContent = "‚ùå Could not generate code.";
    }
  }

  async function restoreCode(){
    try{
      const code = $("saveCode").value.trim();
      const obj = fromSaveCode(code);
      if(!obj || !obj.trainers || obj.trainers.length!==3) throw new Error("bad");
      state = obj;
      await saveState(state);
      await makeBackup(state, `RestoreCode ${new Date().toLocaleString()}`);
      $("saveMsg").textContent = "‚úÖ Restored from code.";
      renderAll();
      refreshBackupCount();
    }catch{
      $("saveMsg").textContent = "‚ùå Code was invalid.";
    }
  }

  async function copyCode(){
    try{
      await navigator.clipboard.writeText($("saveCode").value);
      $("saveMsg").textContent = "üìã Copied.";
    }catch{
      $("saveMsg").textContent = "Copy failed (try long-press ‚Üí copy).";
    }
  }

  /* =========================
     Wire events
     ========================= */

  document.addEventListener("click", (e)=>{
    const el = e.target;
    if(!el) return;

    const view = el.getAttribute("data-view");
    if(view){ switchView(view); return; }

    const hatchId = el.getAttribute("data-hatch");
    if(hatchId){ hatchEgg(hatchId); return; }

    const favId = el.getAttribute("data-fav");
    if(favId){ toggleFavorite(favId); return; }

    const relId = el.getAttribute("data-release");
    if(relId){ releasePokemon(relId); return; }
  });

  $("btnWildEgg").addEventListener("click", claimWildEgg);
  $("btnBuyEgg").addEventListener("click", buyEgg);

  $("btnStartSearch").addEventListener("click", startBiomeSearch);
  $("btnClaimSearchEgg").addEventListener("click", claimBiomeEgg);

  $("btnBreed").addEventListener("click", startBreed);

  $("btnTrade").addEventListener("click", openTrade);
  $("btnDoTrade").addEventListener("click", doTrade);
  $("btnCloseTrade").addEventListener("click", ()=>$("dlgTrade").close());
  $("tradeType").addEventListener("change", rebuildTrade);

  $("btnEditNames").addEventListener("click", ()=>{
    $("dlgNames").showModal();
    $("n1").value = state.trainers[0].name;
    $("n2").value = state.trainers[1].name;
    $("n3").value = state.trainers[2].name;
  });
  $("btnCloseNames").addEventListener("click", ()=>$("dlgNames").close());
  $("btnSaveNames").addEventListener("click", ()=>{
    state.trainers[0].name = $("n1").value.trim() || "Trainer 1";
    state.trainers[1].name = $("n2").value.trim() || "Trainer 2";
    state.trainers[2].name = $("n3").value.trim() || "Trainer 3";
    queueSave();
    $("dlgNames").close();
    renderAll();
  });

  $("btnSaveTools").addEventListener("click", async ()=>{
    $("dlgSave").showModal();
    $("saveMsg").textContent = "";
    await refreshBackupCount();
  });
  $("btnCloseSave").addEventListener("click", ()=>$("dlgSave").close());
  $("btnBackupNow").addEventListener("click", backupNow);
  $("btnDownloadBackup").addEventListener("click", downloadLatestBackup);
  $("fileRestore").addEventListener("change", (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(f) restoreFromFile(f);
    ev.target.value = "";
  });
  $("btnGenCode").addEventListener("click", genCode);
  $("btnRestoreCode").addEventListener("click", restoreCode);
  $("btnCopyCode").addEventListener("click", copyCode);

  $("btnReset").addEventListener("click", async ()=>{
    const ok = confirm("Reset EVERYTHING on this device? This cannot be undone.");
    if(!ok) return;
    // clear DB
    await new Promise((resolve)=>{ const r=indexedDB.deleteDatabase(DB_NAME); r.onsuccess=r.onerror=r.onblocked=()=>resolve(); });
    try{ localStorage.removeItem("eggbound_legacy_mirror"); }catch{}
    state = defaultState();
    await saveState(state);
    await makeBackup(state, "Fresh Start");
    renderAll();
  });

  $("search").addEventListener("input", renderView);
  $("sort").addEventListener("change", renderView);

  // Live timers
  setInterval(()=>{ if(state){ renderEggButtons(); renderView(); } }, 1000);

  // Init biomes
  function populateBiomes(){
    $("biomeSelect").innerHTML = BIOMES.map(b=>`<option value="${b.id}">${b.name} (${b.types.join("/")})</option>`).join("");
  }

  // Startup
  (async function boot(){
    try{
      state = await loadState();
      await saveState(state);         // ensure DB written
      await ensureDailyBackup(state); // daily backup
      await refreshBackupCount();
      setSaveHealth("OK");
    }catch{
      state = defaultState();
      try{ await saveState(state); }catch{}
      setSaveHealth("Degraded");
    }

    populateBiomes();
    renderAll();

    // SW
    if("serviceWorker" in navigator){
      navigator.serviceWorker.register("sw.js").catch(()=>{});
    }
  })();

})();
</script>
</body>
</html>
